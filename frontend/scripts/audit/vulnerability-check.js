#!/usr/bin/env node

/**
 * Maku.Travel Vulnerability Scanner
 * Scans npm packages for known security vulnerabilities
 */

const { execSync } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

class VulnerabilityChecker {
  constructor() {
    this.vulnerabilities = [];
    this.packageInfo = {};
  }

  async checkPackageVulnerabilities() {
    console.log('ðŸ“¦ Checking package vulnerabilities...');
    
    try {
      // Run npm audit and capture output
      const auditResult = execSync('npm audit --json', { 
        encoding: 'utf8',
        stdio: ['pipe', 'pipe', 'pipe']
      });
      
      const auditData = JSON.parse(auditResult);
      this.processAuditResults(auditData);
      
    } catch (error) {
      // npm audit returns non-zero exit code when vulnerabilities found
      if (error.stdout) {
        try {
          const auditData = JSON.parse(error.stdout);
          this.processAuditResults(auditData);
        } catch (parseError) {
          console.error('Failed to parse npm audit output:', parseError);
        }
      } else {
        console.error('npm audit failed:', error.message);
      }
    }
  }

  processAuditResults(auditData) {
    if (auditData.vulnerabilities) {
      Object.entries(auditData.vulnerabilities).forEach(([packageName, vuln]) => {
        this.vulnerabilities.push({
          package: packageName,
          severity: vuln.severity,
          title: vuln.via?.[0]?.title || 'Unknown vulnerability',
          range: vuln.range,
          fixAvailable: vuln.fixAvailable,
          url: vuln.via?.[0]?.url,
          cwe: vuln.via?.[0]?.cwe
        });
      });
    }

    if (auditData.metadata) {
      this.packageInfo = {
        dependencies: auditData.metadata.dependencies,
        devDependencies: auditData.metadata.devDependencies,
        optionalDependencies: auditData.metadata.optionalDependencies,
        totalDependencies: auditData.metadata.totalDependencies
      };
    }
  }

  async checkOutdatedPackages() {
    console.log('ðŸ“… Checking for outdated packages...');
    
    try {
      const outdatedResult = execSync('npm outdated --json', { 
        encoding: 'utf8',
        stdio: ['pipe', 'pipe', 'pipe']
      });
      
      const outdatedData = JSON.parse(outdatedResult);
      this.processOutdatedResults(outdatedData);
      
    } catch (error) {
      // npm outdated returns non-zero when packages are outdated
      if (error.stdout) {
        try {
          const outdatedData = JSON.parse(error.stdout);
          this.processOutdatedResults(outdatedData);
        } catch (parseError) {
          // No outdated packages or parse error
        }
      }
    }
  }

  processOutdatedResults(outdatedData) {
    Object.entries(outdatedData).forEach(([packageName, info]) => {
      const isSecurityUpdate = this.isMajorVersionUpdate(info.current, info.latest);
      
      this.vulnerabilities.push({
        package: packageName,
        severity: isSecurityUpdate ? 'moderate' : 'low',
        title: 'Outdated package',
        current: info.current,
        wanted: info.wanted,
        latest: info.latest,
        type: 'outdated',
        fixAvailable: true
      });
    });
  }

  isMajorVersionUpdate(current, latest) {
    try {
      const currentMajor = parseInt(current.split('.')[0]);
      const latestMajor = parseInt(latest.split('.')[0]);
      return latestMajor > currentMajor;
    } catch {
      return false;
    }
  }

  async generateReport() {
    const reportDir = path.join(process.cwd(), 'reports', 'vulnerabilities');
    await fs.mkdir(reportDir, { recursive: true });

    const criticalCount = this.vulnerabilities.filter(v => v.severity === 'critical').length;
    const highCount = this.vulnerabilities.filter(v => v.severity === 'high').length;
    const moderateCount = this.vulnerabilities.filter(v => v.severity === 'moderate').length;
    const lowCount = this.vulnerabilities.filter(v => v.severity === 'low').length;

    const report = {
      scan_date: new Date().toISOString(),
      summary: {
        total_vulnerabilities: this.vulnerabilities.length,
        critical: criticalCount,
        high: highCount,
        moderate: moderateCount,
        low: lowCount,
        fixable: this.vulnerabilities.filter(v => v.fixAvailable).length
      },
      package_info: this.packageInfo,
      vulnerabilities: this.vulnerabilities,
      recommendations: this.generateRecommendations()
    };

    const reportPath = path.join(reportDir, `vulnerability-report-${new Date().toISOString().split('T')[0]}.json`);
    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));

    console.log(`\nðŸ“Š Vulnerability Report:`);
    console.log(`   Critical: ${criticalCount}`);
    console.log(`   High: ${highCount}`);
    console.log(`   Moderate: ${moderateCount}`);
    console.log(`   Low: ${lowCount}`);
    console.log(`   Fixable: ${report.summary.fixable}`);
    console.log(`   Report saved: ${reportPath}`);

    if (criticalCount > 0 || highCount > 0) {
      console.log('\nâŒ Critical or high severity vulnerabilities found!');
      process.exit(1);
    }

    return report;
  }

  generateRecommendations() {
    const recommendations = [];

    const criticalVulns = this.vulnerabilities.filter(v => v.severity === 'critical');
    if (criticalVulns.length > 0) {
      recommendations.push({
        priority: 'IMMEDIATE',
        action: 'Fix critical vulnerabilities immediately',
        packages: criticalVulns.map(v => v.package),
        command: 'npm audit fix --force'
      });
    }

    const highVulns = this.vulnerabilities.filter(v => v.severity === 'high');
    if (highVulns.length > 0) {
      recommendations.push({
        priority: 'HIGH',
        action: 'Fix high severity vulnerabilities within 24 hours',
        packages: highVulns.map(v => v.package),
        command: 'npm audit fix'
      });
    }

    const fixableCount = this.vulnerabilities.filter(v => v.fixAvailable).length;
    if (fixableCount > 0) {
      recommendations.push({
        priority: 'MEDIUM',
        action: `Run npm audit fix to automatically resolve ${fixableCount} vulnerabilities`,
        command: 'npm audit fix'
      });
    }

    const outdatedPackages = this.vulnerabilities.filter(v => v.type === 'outdated');
    if (outdatedPackages.length > 0) {
      recommendations.push({
        priority: 'LOW',
        action: 'Update outdated packages',
        packages: outdatedPackages.map(v => v.package),
        command: 'npm update'
      });
    }

    return recommendations;
  }

  async run() {
    console.log('ðŸš€ Starting Vulnerability Check...');
    
    await this.checkPackageVulnerabilities();
    await this.checkOutdatedPackages();
    
    return await this.generateReport();
  }
}

// Run if called directly
if (require.main === module) {
  const checker = new VulnerabilityChecker();
  checker.run().catch(error => {
    console.error('Vulnerability check failed:', error);
    process.exit(1);
  });
}

module.exports = VulnerabilityChecker;