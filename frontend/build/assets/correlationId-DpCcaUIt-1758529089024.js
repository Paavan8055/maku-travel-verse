const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-CCJXHVND-1758529089024.js","assets/index-A1xnoR0S-1758529089024.css"])))=>i.map(i=>d[i]);
var D=Object.defineProperty;var U=(t,e,r)=>e in t?D(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var s=(t,e,r)=>U(t,typeof e!="symbol"?e+"":e,r);import{_ as b}from"./index-CCJXHVND-1758529089024.js";const n=[];for(let t=0;t<256;++t)n.push((t+256).toString(16).slice(1));function x(t,e=0){return(n[t[e+0]]+n[t[e+1]]+n[t[e+2]]+n[t[e+3]]+"-"+n[t[e+4]]+n[t[e+5]]+"-"+n[t[e+6]]+n[t[e+7]]+"-"+n[t[e+8]]+n[t[e+9]]+"-"+n[t[e+10]]+n[t[e+11]]+n[t[e+12]]+n[t[e+13]]+n[t[e+14]]+n[t[e+15]]).toLowerCase()}let l;const C=new Uint8Array(16);function S(){if(!l){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");l=crypto.getRandomValues.bind(crypto)}return l(C)}const R=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),m={randomUUID:R};function v(t,e,r){var u,c,i;if(m.randomUUID&&!t)return m.randomUUID();t=t||{};const o=(i=(c=t.random)!=null?c:(u=t.rng)==null?void 0:u.call(t))!=null?i:S();if(o.length<16)throw new Error("Random bytes length must be >= 16");return o[6]=o[6]&15|64,o[8]=o[8]&63|128,x(o)}const a=class a{constructor(){s(this,"currentId",null)}static getInstance(){return a.instance||(a.instance=new a),a.instance}generateId(){return this.currentId=v(),this.currentId}getCurrentId(){return this.currentId||this.generateId()}setId(e){this.currentId=e}clear(){this.currentId=null}getHeaders(e={}){return{"X-Correlation-ID":this.getCurrentId(),...e}}async logCorrelationData(e,r,o,u,c,i,p,y){try{const{supabase:d}=await b(async()=>{const{supabase:_}=await import("./index-CCJXHVND-1758529089024.js").then(w=>w.aW);return{supabase:_}},__vite__mapDeps([0,1])),h={correlation_id:this.getCurrentId(),request_type:e,status:r,request_data:{...o,...c?{service_name:c}:{},...i?{error_message:i}:{}},response_data:u,duration_ms:p,user_id:y,created_at:new Date().toISOString(),completed_at:r!=="in_progress"?new Date().toISOString():null},{error:I}=await d.from("correlation_tracking").upsert(h);I&&console.error("Failed to log correlation data:",I)}catch(d){console.error("Error logging correlation data:",d)}}extractFromHeaders(e){return e instanceof Headers?e.get("X-Correlation-ID"):e["X-Correlation-ID"]||e["x-correlation-id"]||null}};s(a,"instance");let g=a;const E=g.getInstance(),O=t=>({...t,correlationId:E.getCurrentId()});export{E as c,O as w};
